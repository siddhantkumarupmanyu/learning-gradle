/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/7.5/samples
 */

// https://docs.gradle.org/current/userguide/build_lifecycle.html

println("This is executed during the configuration phase")

tasks.register("configured") {
    println("This is also executed during the configuration phase, because :configured is used in the build.")
}

tasks.register("test") {
    doLast {
        println("This is executed during the execution phase.")
    }
}

tasks.register("testBoth") {
    doFirst {
        println("This is executed first during the execution phase.")
    }
    doLast {
        println("This is executed last during the execution phase.")
    }
    println("This is executed during the configuration phase as well, because :testBoth is used in the build.")
}

// now this is what i like
// how kotlin syntactic features help build an elegant dsl...
// and its also understandable, while being readable...
// else builder pattern and stuff a bit more verbose than necessary...
// also, in those cases we lose the readability more than we lose understandability here...
// in this case, it's fine, since it's a different language all together, dsl
// so a bit of understandability going down is ok...
// complex things requires complex setup/code/work

gradle.afterProject {
    if (state.failure != null) {
        println("Evaluation of $project FAILED")
    } else {
        println("Evaluation of $project succeeded")
    }
}


tasks.whenTaskAdded {
    extra["srcDir"] = "src/main/java"
}

val a by tasks.registering

println("source dir is ${a.get().extra["srcDir"]}")


tasks.register("ok")

tasks.register("broken") {
    dependsOn("ok")
    doLast {
        throw RuntimeException("broken")
    }
}

gradle.taskGraph.beforeTask {
    println("executing $this")
}

gradle.taskGraph.afterTask{
    if(state.failure != null){
        println("FAILED")
    }else{
        println("done")
    }
}